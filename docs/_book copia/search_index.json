[["miscellania.html", "Chapter 7 Miscellania 7.1 Representation of predicted disordered amino acid data 7.2 Shannon’s entropy", " Chapter 7 Miscellania Here, you can explore how we implement some calculations and their visualizations of various issues using Python. 7.1 Representation of predicted disordered amino acid data We import some libraries. import matplotlib.pyplot as plt import pandas as pd import seaborn as sns Now, we read a CSV file containing disordered data and a few other characteristics of each protein. df_disorder = pd.read_csv(&quot;/Users/esmeralda/Documents/TFM/article/disorder_data.csv&quot;, sep=&quot;;&quot;) df_disorder[&#39;Length&#39;] = pd.to_numeric(df_disorder[&#39;Length&#39;], errors=&#39;coerce&#39;) We define for the following plots in Seaborn: The style The palette # Set Seaborn style to match a similar style to Plotly sns.set(rc={&#39;axes.facecolor&#39;: &#39;white&#39;, &#39;axes.edgecolor&#39;: &#39;white&#39;, &quot;axes.grid&quot;: True, &quot;grid.linestyle&quot;: &quot;--&quot;, &quot;font.size&quot;: 15, &quot;axes.labelsize&quot;: 15, &quot;xtick.labelsize&quot;: 12, &quot;ytick.labelsize&quot;: 12, &#39;xtick.bottom&#39;: True, &#39;figure.facecolor&#39;: &#39;white&#39;, &#39;xtick.top&#39;: False, &#39;xtick.bottom&#39;: False, &#39;ytick.left&#39;: True, &#39;ytick.right&#39;: False, &quot;grid.color&quot;: &quot;#DFDFDF&quot;, &#39;font.sans-serif&#39;: &#39;Helvetica&#39;}) safe_colorblind_palette = [&quot;#E69F00&quot;, &quot;#6D0000&quot;, &quot;#56B4E9&quot;, &quot;#97E4CF&quot;, &quot;#F0E442&quot;, &quot;#0F425F&quot;, &quot;#D55E00&quot;, &quot;#000877&quot;, &quot;#CA4E93&quot;, &quot;#ABB6D3&quot;, &quot;#D9F221&quot;] # Create a figure and axes plt.figure(figsize=(10, 6)) ax = sns.boxplot(data=df_disorder[df_disorder[&quot;Movement protein&quot;] == &quot;Movement protein&quot;], x=&quot;Taxonomy origin&quot;, y=&quot;Percentage&quot;, color=&quot;white&quot;, boxprops=dict(edgecolor=&#39;black&#39;), whiskerprops=dict(color=&#39;black&#39;), medianprops=dict(color=&#39;black&#39;), capprops=dict(linewidth=2), width=0.7, linewidth=0.6) marker_style = [] for i in df_disorder[&quot;Movement protein&quot;]: if i == &#39;o&#39;: marker_style.append(&#39;o&#39;) else: marker_style.append(&#39;X&#39;) We can plot disorder data classified by taxonomic families. ax = sns.swarmplot(data=df_disorder, x=&quot;Taxonomy origin&quot;, y=&quot;Percentage&quot;, color=&quot;black&quot;, palette=safe_colorblind_palette, size=7, marker=&quot;X&quot;) ax = sns.swarmplot(data=df_disorder[df_disorder[&quot;Movement protein&quot;] == &quot;Movement protein&quot;], x=&quot;Taxonomy origin&quot;, y=&quot;Percentage&quot;, color=&quot;black&quot;, palette=safe_colorblind_palette, marker=&quot;o&quot;, size=7) # Set plot labels and title plt.xlabel(&quot;Genus&quot;) plt.ylabel(&quot;% predicted disodered residues&quot;) # Adjust plot layout plt.xticks(rotation=45) plt.tight_layout() plt.savefig(&quot;percentage_taxonomy.pdf&quot;, format=&quot;pdf&quot;) # Display the plot plt.show() In this case, we create a plot for all the proteins, categorizing them based on whether their corresponding open reading frames are overprinted. safe_colorblind_palette_2 = [&quot;#054C6F&quot;, &quot;#44AA99&quot;] # Create a figure and axes plt.figure(figsize=(5, 6)) ax = sns.boxplot(data=df_disorder[df_disorder[&quot;Movement protein&quot;] == &quot;Movement protein&quot;], x=&quot;Overlap&quot;, y=&quot;Percentage&quot;, color=&quot;white&quot;, boxprops=dict(edgecolor=&#39;black&#39;), whiskerprops=dict(color=&#39;black&#39;), medianprops=dict(color=&#39;black&#39;), capprops=dict(linewidth=2), width=0.7, linewidth=0.6) ax = sns.swarmplot(data=df_disorder, x=&quot;Overlap&quot;, y=&quot;Percentage&quot;, color=&quot;black&quot;, palette=safe_colorblind_palette_2, marker=&quot;X&quot;, size=7) ax = sns.swarmplot(data=df_disorder[df_disorder[&quot;Movement protein&quot;] == &quot;Movement protein&quot;], x=&quot;Overlap&quot;, y=&quot;Percentage&quot;, color=&quot;black&quot;, palette=safe_colorblind_palette_2, marker=&quot;o&quot;, size=7) # Set plot labels and title plt.xlabel(&quot;&quot;) plt.ylabel(&quot;% predicted disodered residues&quot;) # Adjust plot layout plt.xticks(rotation=45) plt.tight_layout() plt.savefig(&quot;percentage_overprinted.pdf&quot;, format=&quot;pdf&quot;) # Display the plot plt.show() Then, we can also create a scatter plot, utilizing the length of our proteins as a variable. plt.figure(figsize=(8, 6)) markers = {&quot;Movement protein&quot;: &quot;o&quot;, &quot;p19&quot;: &quot;X&quot;} sns.scatterplot(data=df_disorder, x=&#39;Length&#39;, y=&#39;Disordered residues&#39;, hue=&#39;Taxonomy origin&#39;, style=&quot;Movement protein&quot;, markers=markers, palette=safe_colorblind_palette, s=40) plt.legend([],[], frameon=False) plt.xlabel(&quot;Length&quot;) plt.ylabel(&quot;Predicted disordered residues&quot;) plt.savefig(&quot;disorder_scatter_taxonomy_legend.pdf&quot;, format=&quot;pdf&quot;) plt.show() Last but not least, in the previous plot, we can use color to distinguish proteins based on whether they were overprinted or not. plt.figure(figsize=(8, 6)) ax = sns.scatterplot(data=df_disorder, x=&#39;Length&#39;, y=&#39;Disordered residues&#39;, hue=&#39;Overlap&#39;,style=&quot;Movement protein&quot;, palette=safe_colorblind_palette_2, s=40) plt.xlabel(&quot;Length&quot;) plt.ylabel(&quot;Predicted disordered residues&quot;) plt.legend([],[], frameon=False) plt.savefig(&quot;disorder_scatter_overlap_legend.pdf&quot;, format=&quot;pdf&quot;) plt.show() 7.2 Shannon’s entropy In this final section, we demonstrate how to implement Shannon’s entropy in Python and visually represent the data. First of all, we load the following libraries. from Bio import SeqIO import pandas as pd import scipy.stats import matplotlib.pyplot as plt import numpy as np import seaborn as sns from statannotations.Annotator import Annotator import itertools We have created two functions — one to read and another to drop the dashes from the data. def reading_alignment(name_file): record_dict = SeqIO.to_dict(SeqIO.parse(name_file, &quot;fasta&quot;)) df_init = pd.DataFrame.from_dict(record_dict) return df_init def dropping_dashes(datafr): datafr_res = [] indexes_dash = [] for i in range(len(datafr.index)): total = datafr.iloc[i].value_counts() if &quot;-&quot; in total.index and len(total.index) == 1: indexes_dash.append(i) datafr_res.append(datafr.drop(datafr.index[indexes_dash])) return datafr_res The following function is designed to calculate and store the entropy values. def calc_entropy(df, base=2): entropies = [] for row in df.index: counts = (df.loc[row].value_counts()) entropies.append(scipy.stats.entropy(counts, base=base)) return pd.DataFrame(entropies, columns=[&quot;Entropy&quot;]) Finally, we used two functions to generate a visualization of the entropy along the sequences of each sequence analyzed and their distributions. For the distribution plots, the package statannotations allows us to add significance indicators calculated with the Mann-Whitney U test. Both plots are then saved as PDF files. def plot_positions(dataframe, name, type): with sns.plotting_context(&#39;notebook&#39;, font_scale = 1.2): plt.figure(figsize=(12, 5)) plt.bar(x=dataframe.index, height=dataframe[&quot;Entropy&quot;], color=dataframe[&quot;Color&quot;]) # plt.title(&#39;Shannon Entropy per Position&#39;) plt.xlabel(&#39;Position (&#39; + type + &#39;)&#39;) plt.ylabel(&quot;Shannon&#39;s Entropy&quot;) plt.xlim(0,len(dataframe.index)) plt.savefig(name, format=&#39;pdf&#39;) plt.show() def plot_distribution(result_df, color_orf, x_labels, type, name): categories = list(set(result_df[&quot;Color&quot;])) pairs = [] p_values = [] group_pairs = list(itertools.combinations(categories, 2)) # Perform Mann-Whitney U test for each pair for pair in group_pairs: categ, categ_2 = pair #print(result_df_clean[nan_mask.any(axis=1)]) p_values.append(scipy.stats.mannwhitneyu(result_df[result_df[&quot;Color&quot;] == categ][&quot;Entropy&quot;], result_df[result_df[&quot;Color&quot;] == categ_2][&quot;Entropy&quot;], alternative=&quot;two-sided&quot;).pvalue) pairs.append((categ, categ_2)) formatted_pvalues = [f&#39;p={pvalue:.3e}&#39; for pvalue in p_values] with sns.plotting_context(&#39;notebook&#39;, font_scale = 1.2): fig, ax = plt.subplots(figsize=(6, 6)) sns.stripplot(data=result_df, x=&quot;Color&quot;, y=&quot;Entropy&quot;, ax=ax, palette=color_orf, jitter=True, size=2) sns.boxplot(data=result_df, x=&quot;Color&quot;, y=&quot;Entropy&quot;, zorder=0, dodge=True, ax=ax, boxprops={&#39;facecolor&#39;:&#39;None&#39;}) ax.set_xticks(ax.get_xticks()) ax.set_xticklabels(x_labels) ax.set_xlabel(type) ax.set_ylabel(&quot;Shannon&#39;s Entropy&quot;) # Add annotations annot = Annotator(ax=ax, pairs = pairs, data=result_df, x=&quot;Color&quot;, y=&quot;Entropy&quot;) annot.set_custom_annotations(formatted_pvalues) annot.configure(test_short_name=&quot;MWW&quot;) # text_format is still simple annot.set_pvalues_and_annotate(p_values) plt.savefig(name, format=&#39;pdf&#39;) plt.show() Now, we apply the functions and select specific features as colors for display. We repeat these steps twice, once for nucleotides and once for amino acids. def main(): ############################################################################ # NUCLEOTIDES # ############################################################################ RdRp_nt_file = &quot;/Users/esmeralda/Documents/TFM/article/alignments/RdRp_nt_aligned.fasta&quot; cp_nt_file = &quot;/Users/esmeralda/Documents/TFM/article/alignments/cp_nt_aligned_filtered.fasta&quot; p22_nt_file = &quot;/Users/esmeralda/Documents/TFM/article/alignments/p22_nt_alignment.fasta&quot; list_df = [RdRp_nt_file, cp_nt_file, p22_nt_file] all_res = [] for name_df in list_df: df_init = reading_alignment(name_df) df_filtered = dropping_dashes(df_init) all_res.append(calc_entropy(df_filtered[0])) color_orf = [&quot;#E07A5F&quot;, &quot;#ECBC6F&quot;, &quot;#81B29A&quot;, &quot;#3D405B&quot;] len_orf1 = 993 + 81 all_res[0][&quot;Color&quot;] = [color_orf[0]]*len_orf1 + [color_orf[1]]*(len(all_res[0].index)-len_orf1) all_res[1][&quot;Color&quot;] = color_orf[2] all_res[2][&quot;Color&quot;] = color_orf[3] result_df = pd.concat(all_res, ignore_index=True) plot_positions(result_df, &#39;/Users/esmeralda/Documents/TFM/Review/entropy_plot.pdf&#39;, type=&quot;nucleotides&quot;) x_labels = [&quot;ORF1&quot;,&quot;RdRp&quot;, &quot;CP&quot;, &quot;p22/p19&quot;] plot_distribution(result_df, color_orf, x_labels, &quot;CDS&quot;, &#39;/Users/esmeralda/Documents/TFM/Review/entropy_dist_nt.pdf&#39;) results_codons = result_df[&quot;Entropy&quot;] ############################################################################ # AMINO ACIDS # ############################################################################ RdRp_file = &quot;/Users/esmeralda/Documents/TFM/article/alignments/RdRp_aligned.fa&quot; cp_file = &quot;/Users/esmeralda/Documents/TFM/article/alignments/cp_aligned.fa&quot; p22_file = &quot;/Users/esmeralda/Documents/TFM/article/alignments/p22_alignment_33.fa&quot; p19_file = &quot;/Users/esmeralda/Documents/TFM/article/alignments/p19_aligned.fa&quot; list_df = [RdRp_file, cp_file, p22_file, p19_file] all_res = [] for name_df in list_df: df_init = reading_alignment(name_df) df_filtered = dropping_dashes(df_init) all_res.append(calc_entropy(df_filtered[0])) color_orf = [&quot;#E07A5F&quot;, &quot;#ECBC6F&quot;, &quot;#81B29A&quot;, &quot;#3D405B&quot;, &quot;#B5AA9D&quot;] len_orf1 = (993 + 81)//3 all_res[0][&quot;Color&quot;] = [color_orf[0]]*len_orf1 + [color_orf[1]]*(len(all_res[0].index)-(len_orf1)) all_res[1][&quot;Color&quot;] = color_orf[2] all_res[2][&quot;Color&quot;] = color_orf[3] all_res[3][&quot;Color&quot;] = color_orf[4] result_df = pd.concat(all_res, ignore_index=True) plot_positions(result_df, &#39;/Users/esmeralda/Documents/TFM/Review/entropy_plot_aa.pdf&#39;, &#39;amino acids&#39;) x_labels = [&quot;p33&quot;,&quot;p92&quot;, &quot;CP&quot;, &quot;p22&quot;, &quot;p19&quot;] plot_distribution(result_df, color_orf, x_labels, &quot;Product&quot;, &#39;/Users/esmeralda/Documents/TFM/Review/entropy_dist_aa.pdf&#39;) results_aa = result_df[&quot;Entropy&quot;] # Kruskal-Wallis test statistic, p_value = scipy.stats.kruskal(results_codons, results_aa) print(statistic, p_value) if __name__ == &quot;__main__&quot;: main() "]]
